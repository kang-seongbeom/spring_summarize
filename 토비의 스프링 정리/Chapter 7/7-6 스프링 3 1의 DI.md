# 7.6 스프링 3.1의 DI

7.6.1 애노테이션의 메타정보 활용

- 초기 리플렉션 API는 자바 코드나 컴포넌트를 작성하는데 사용되는 툴을 개발할 때 이용하도록 만들어졌음
- 이후, 자바 코드의 **메타정보**를 데이터를 활용하는 스타일의 프로그래밍 방식에서 리플렉션 API를 활용하도록 변화됨
- 해당 프로그래밍 방식의 절정이 **애노테이션**임
- 리프렉션 API를 이용해 애노테이션의 메타정보를 조회하고 가져오는 방법이 전부임
- 애노테이션 자체가 클래스의 타입에 영향을 주지 못하고, 코드에서 활용될수 없어 OOP 스타일의 코드나 패턴을 적용할 수 없음
- 하지만, 애노테이션은 애플리케이션의 **핵심 로직**과 이를 지원하는 **Ioc 프레임워크**와 잘 어울림
- 애노테이션은 Ioc 프레임워크가 **참조**하는 **메타정보**로 사용되기 때문에 애노테이션의 활용도가 증가하고 있음
- 프레임워크에서 XML을 DI용 **메타정보**로 활용하기 때문에, 간결한 코딩이 가능했음
- 하지만, XML은 표현하려는 정보를 모두 명시적으로 나타내야 함
    
    ```xml
    <x:special target="type" class="com.mycompany.myproject.MyClass" />
    ```
    
- 이와 대조적으로 애노테이션을  추가하는 것 만으로 리플렉션 API를 활용해 패키지, 클래스 이름, 접근 제한자, 구현 인터페이스 등의 여러 정보를 얻을 수 있음
    
    ```java
    @Special
    public class MyClass{...}
    ```
    
- 물론, 애노테이션에도 단점이 존재함
- XML 변경 시  빌드 과정을 생략해도 되지만, 애노테이션은 자바 코드에 존재하므로 빌드를 새로 해 줘야 함
- **자바 개발 흐름**은 점차 XML 같은 텍스트 형태의 메타정보를 활용을 자바 코드에 내장된 애노테이션을 대체하는 쪽으로 가고 있음**[Spring-Boot]**
- 스프링 2.5 버전에서 부터 스프링 일부에 애노테이션을 적용하기 시작했음
- 3.0까지 XML을 완전히 배제하는 것이 불가능 했지만, 3.1 부터 거의 모든 영역에 XML 대신 애노테이션으로 대체할 수 있게 변경됨

7.6.2 정책과 관례를 이용한 프로그래밍

- 애노테이션 같은 메타정보를 활용하는 프로그래밍 방식은 명시적으로 동작 코드를 기술하는 대신, 코드 없이도 미리 약속된 **규칙** 또는 **관례**를 따라 프로그램이 동작하도록 함
- 미리 약속된 규칙과 관례에 따라 프레임워크가 작업을 수행하기 때문에, 많은 코드의 내용을  생략할 수 있음
- 하지만, 미리 정의된 규칙과 관례를 기억 해야하는 부담이 있음
- 스프링은 루비 언어를 기반으로한 RoR **프레임워크**에 영향을 받았음
- 스프링은 XML 또는 애노테이션의 **메타정보**를 활용한 프레임워크이기 때문에, 코드가 매우 간략할 수 있음
- 스프링은 애노테이션으로 메타정보를 활용하는 방식을 적극 도입하고 있음

7.6.3 지금 까지 만든 XML

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans >

    <tx:annotation-driven/>

    <context:annotation-config/>

    <jdbc:embedded-database id="embeddedDatabase" type="HSQL">
        <jdbc:script location="schema.sql"/>
    </jdbc:embedded-database>

    <bean id="testUserService"
          class="com.ksb.spring.UserServiceImpl$TestUserService"
          parent="userService">
    </bean>

    <bean id="userService" class="com.ksb.spring.UserServiceImpl">
        <property name="userDao" ref="userDao"/>
        <property name="mailSender" ref="mailSender"/>
    </bean>

    <bean id="mailSender"
          class="com.ksb.spring.DummyMailSender">
        <property name="host" value="mail.server.com"/>
    </bean>

    <bean id="transactionManager"
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>

    <bean id="userDao" class="com.ksb.spring.UserDaoJdbc">
        <property name="dataSource" ref="dataSource"/>
        <property name="sqlService" ref="sqlService"/>
    </bean>

    <bean id="sqlService" class="com.ksb.spring.OxmSqlService">
        <property name="unmarshaller" ref="unmarshaller"/>
				<!--디폴트-->
        <!--<property name="sqlmap" value="classpath:/sqlmap.xml"/>-->
        <property name="sqlRegistry" ref="sqlRegistry"/>
    </bean>

    <bean id="sqlRegistry" class="com.ksb.spring.EmbeddedDbSqlRegistry">
        <property name="dataSource" ref="embeddedDatabase"/>
    </bean>

    <bean id="unmarshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
        <property name="contextPath" value="com.ksb.spring.jaxb"/>
    </bean>

    <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
        <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost/toby?serverTimezone=UTC"/>
        <property name="username" value="root"/>
        <property name="password" value="1234"/>
    </bean>
</beans>
```

7.6.4 테스트 컨텍스트 변경

- 애노테이션과 자바코드로 기존의 XML로 만든 설정정보를 대체할 것임
- XML을 더 이상 사용하지 않게 하는 것이 **최종 목적**임
- 스프링 3.1은 자바 코드 설정 정보에서 XML과 자바 코드로 만들어진 DI을 동시에 사용할 방법을 제공하고 있음
- @ImportResource가 바로 그것임
    
    ```java
    /*애노테이션을 활용한 자바 코드 설정 정보를 만듦.
      아직 아무런 설정 정보가 없기 때문에, XML의 설정 정보를 가져옴
    */
    @Configuration
    @ImportResource("/applicationContext.xml")
    public class TestApplicationContext {
    }
    ```
    
- 정상적으로 동작하는 것을 확인하기 위해 테스트 코드를 돌려봐야 함
- 기존 XML을 사용하는 테스트인 UserDaoTest와 UserServiceTest에서 설정 정보를 가져오는 부분을 수정해야 함
    
    ```java
    //@ContextConfiguration에서 XML아닌 자바 코드 설정정보를 가져오도록 수정
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(classes = TestApplicationContext.class)
    public class UserDaoTest {
    }
    
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(classes = TestApplicationContext.class)
    public class UserServiceTest {
    }
    ```
    

7.6.5 <context:annotation-config /> 제거

- <context:annotation-config />는 @PostConstruct를 붙인 메소드가 빈이 초기화된 이후에 자동으로 실행되도록 함
- 즉, @PostConstruct와 같은 표준 애노테이션을 인식해 자동으로 메소도를 실행시킴
- 예를 들어, `OxmSqlService`의 loadsql() 메소드는 `OxmSqlService`가 올바르게 동작하기 위해 미리 실행돼야 하므로 @PostConstruct를 부여했음
- XML에 담긴 DI 정보를 이용하는 스프링 컨테이너를 사용하는 경우에 @PostConstruct와 같은 애노테이션의 기능이 필요하면 반드시 <context:annotation-config />를 포함해 필요한 **빈 후처리기**가 **등록**되게 만들어야 함
- 반면에, XML이 아닌 **@Configaration**이 붙은 **설정 클래스**를 사용하는 경우 <context:annotation-config />가 필요 없음
- 이유는, 컨테이너가 직접 @PostConstruct 애노테이션을 처리하는 빈 후처리기를 등록하기 때문임

```xml
<beans>
		<!--제거-->
		~~<context:annotation-config/>~~
</beans>
```

7.6.6 dataSource 빈의 전환

- <bean>은 @Bean과 거의 1:1로 매핑됨
- dataSource 빈에서 id 값은 메소드 이름이고, 리턴 값은 class 값임
    
    ```xml
    <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
        <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost/toby?serverTimezone=UTC"/>
        <property name="username" value="root"/>
        <property name="password" value="1234"/>
    </bean>
    ```
    
- 단, **리턴 값**은 DI의 원리에 따라 빈의 구현 클래스는 자유롭게 변경하기 때문에 실제 구현 클래스가 아닌, 구현한 **인터페이스**로 반환하는 것이 좋음
    
    ```java
    @Bean
    publid DataSource dataSource(){}
    ```
    
- 하지만, XML과 같이 프로퍼티 값 주입을 위해 실제 반환되는 **변수 타입**은 인터페이스를 구현한 클래스(`SimpleDriverDataSource`)로 선언해야 함
- Datasource에는 getConnection()만 있기 때문에, 프로퍼티 값 주입을 위해 구현 클래스가 필요함
    
    ```java
    SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
    ```
    
- 자바 코드에서 프로퍼티 driverClass의 스트링 값을 자동으로 변환하지 않기 때문에, 적절한 타입으로 변환해 주어야 함
    
    ```java
    dataSource.setDriverClass((Class<? extends Driver>) Class.forName("com.mysql.cj.jdbc.Driver"));
    ```
    
- xml 삭제 후 테스트 진행
    
    ```xml
    <!--삭제-->
    ~~<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">~~
        ...
    </bean>
    ```
    
    ```java
    public class TestApplicationContext {
        @Bean
        public DataSource dataSource() public class TestApplicationContext {{
            SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
    
            try {
                dataSource.setDriverClass((Class<? extends Driver>) Class.forName("com.mysql.cj.jdbc.Driver"));
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
            dataSource.setUrl("jdbc:mysql://localhost/toby?serverTimezone=UTC");
            dataSource.setUsername("root");
            dataSource.setPassword("1234");
    
            return dataSource;
        }
    }
    ```
    

7.6.7 transactionManager 빈의 전환

- transactionManager는 프로퍼티로 dataSource 빈을 의존하고 있음
    
    ```xml
    <bean id="transactionManager"
              class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    ```
    
- 자바 코드를 통한 빈의 의존 관계는 빈 메소드를 직접 호출해 리턴 값을 수정자 메소드에 넣으면 됨
    
    ```xml
    ~~<bean id="transactionManager">~~
    ```
    
    ```java
    public class TestApplicationContext {
    		...
    		@Bean
        public PlatformTransactionManager transactionManager() {
            DataSourceTransactionManager tm = new DataSourceTransactionManager();
            tm.setDataSource(dataSource());
            return tm;
        }
    }
    ```
    

7.6.8 나머지 빈의 전환 - 1 

- userDao, userService, testUserService, mailSender 빈 전환
- testUserService는 userService의 프로퍼티 정의 부분을 그대로 상속하게 만들었음
    
    ```xml
    <bean id="testUserService"
          class="com.ksb.spring.UserServiceImpl$TestUserService"
          parent="userService">
    </bean>
    ```
    
- 이전에 만든 `TestUserService` 클래스는 테스트 용도로 만들었고, 내부적으로 리플렉션 API를 사용했기 때문에 private 접근 제한자를 사용해도 문제가 없었음
- 하지만, 자바 코드의 설정 파일은 public만 접근할 수 있기 때문에 public으로 전환 해 줘야 함
    
    ```java
    public static class TestUserService extends UserServiceImpl {}
    ```
    
- 네 개의 빈 전환
    - userDao의 sqlService는 일단 XML에서 주입받아 사용할 수 있게 함
    
    ```xml
    ~~<bean id="userDao" >
    <bean id="sqlService" >
    <bean id="testUserService" >
    <bean id="mailSender" >~~
    ```
    
    ```java
    public class TestApplicationContext {
    		...	
    		@Autowired
        SqlService sqlService;
    
    		@Bean
        public UserDao userDao()  {
            UserDaoJdbc dao = new UserDaoJdbc();
            dao.setDataSource(dataSource());
            dao.setSqlService(this.sqlService);
            return dao;
        }
    
        @Bean
        public UserService userService() {
            UserServiceImpl service = new UserServiceImpl();
            service.setUserDao(userDao());
            service.setMailSender(mailSender());
            return service;
        }
    
        @Bean
        public UserService testUserService(){
            UserServiceImpl.TestUserService testService =
                    new UserServiceImpl.TestUserService();
            testService.setUserDao(userDao());
            testService.setMailSender(mailSender());
            return testService;
        }
    
        @Bean
        public MailSender mailSender(){
            return new DummyMailSender();
        }
    }
    ```
    

7.6.9 나머지 빈의 전환 - 2

- sqlService, sqlRegistry, unmarshaller 빈 전환
- embeddedDatabase를 주입 받을 때 @Resource 애노테이션 사용
- @Resource는 @Autowired와 유사하지만, @Resource는 필드 이름을 기준으로 빈을 찾음
    
    <aside>
    💡 @Autowired는 타입을 기준으로 빈을 찾음
    
    </aside>
    
- 세 개의 빈 전환
    
    ```xml
    ~~<bean id="sqlService" >
    <bean id="sqlRegistry" >
    <bean id="unmarshaller" >~~
    ```
    
    ```java
    public class TestApplicationContext {
    		@Resource
        DataSource embeddedDatabase;
    		...
        @Bean
        public SqlService sqlService(){
            OxmSqlService sqlService = new OxmSqlService();
            sqlService.setUnmarshaller(unmarshaller());
            sqlService.setSqlRegistry(sqlRegistry());
            return sqlService;
        }
    
        @Bean
        public SqlRegistry sqlRegistry(){
            EmbeddedDbSqlRegistry sqlRegistry = new EmbeddedDbSqlRegistry();
            sqlRegistry.setDataSource(this.embeddedDatabase);
            return sqlRegistry;
        }
    
        @Bean
        public Unmarshaller unmarshaller(){
            Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
            marshaller.setContextPath("com.ksb.spring.jaxb");
            return marshaller;
        }
    }
    ```
    
- embeddedDatabase 빈의 경우 전용 태그로 만들었음
    
    ```xml
    <jdbc:embedded-database id="embeddedDatabase" type="HSQL">
        <jdbc:script location="schema.sql"/>
    </jdbc:embedded-database>
    ```
    
- 전용 태그로 만들어지는 빈이 여러 개일 수 있음
- embeddedDatabase는 내장형 DB로 EmbeddedDatabaseBuilder를 이용하면 됨
    
    ```xml
    ~~<jdbc:embedded-database id="embeddedDatabase" type="HSQL">~~
    ```
    
    ```java
    public class TestApplicationContext {
    		~~@Resource
        DataSource embeddedDatabase;~~
    		...
    		@Bean
        public SqlRegistry sqlRegistry(){
            EmbeddedDbSqlRegistry sqlRegistry = new EmbeddedDbSqlRegistry();
            sqlRegistry.setDataSource(embeddedDatabase());
            return sqlRegistry;
        }
    		~~~~@Bean
        public DataSource embeddedDatabase(){
            return new EmbeddedDatabaseBuilder()
                    .setName("embeddedDatabase")
                    .setType(HSQL)
                    .addScript("schema.sql")
                    .build();
        }
    ~~~~}
    ```
    
- 마지막 태그인 <tx:annotation-driven/> 대체
- <tx:annotation-driven/>은 @Transactional이 붙은 곳에 **어드바이스**와 **포인트컷**을 적용하는 기능을 함
- 이 역시 전용 태그로 기본적으로 네 가지 클래스를 빈으로 등록함
- 해당 네 가지 빈을 등록하기 번거롭기도 하고, 기억하기 힘듦
- 스프링 3.1 부터 전용 태그에 대응되는 애노테이션을 제공함
- 해당 애노테이션들은 @Enable로 시작함
- <tx:annotation-driven/>는 @EnableTransactionManagement로 대체할 수 있음
    
    ```xml
    ~~<tx:annotation-driven/>~~
    ```
    
    ```java
    //모든 XML 설정정보를 대체했기 때문에, ImportResource 삭제 가능
    ~~@ImportResource("/applicationContext.xml")~~
    @EnableTransactionManagement
    public class TestApplicationContext {}
    ```
    
- 완성된 애노테이션 기반 설정정보
    
    ```java
    @Configuration
    @EnableTransactionManagement
    public class TestApplicationContext {
    
        @Autowired
        SqlService sqlService;
    
        @Bean
        public DataSource dataSource() {
            SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
    
            try {
                dataSource.setDriverClass((Class<? extends Driver>) Class.forName("com.mysql.cj.jdbc.Driver"));
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
            dataSource.setUrl("jdbc:mysql://localhost/toby?serverTimezone=UTC");
            dataSource.setUsername("root");
            dataSource.setPassword("1234");
    
            return dataSource;
        }
    
        @Bean
        public PlatformTransactionManager transactionManager() {
            DataSourceTransactionManager tm = new DataSourceTransactionManager();
            tm.setDataSource(dataSource());
            return tm;
        }
    
        @Bean
        public UserDao userDao()  {
            UserDaoJdbc dao = new UserDaoJdbc();
            dao.setDataSource(dataSource());
            dao.setSqlService(this.sqlService);
            return dao;
        }
    
        @Bean
        public UserService userService() {
            UserServiceImpl service = new UserServiceImpl();
            service.setUserDao(userDao());
            service.setMailSender(mailSender());
            return service;
        }
    
        @Bean
        public UserService testUserService(){
            UserServiceImpl.TestUserService testService =
                    new UserServiceImpl.TestUserService();
            testService.setUserDao(userDao());
            testService.setMailSender(mailSender());
            return testService;
        }
    
        @Bean
        public MailSender mailSender(){
            return new DummyMailSender();
        }
    
        @Bean
        public SqlService sqlService(){
            OxmSqlService sqlService = new OxmSqlService();
            sqlService.setUnmarshaller(unmarshaller());
            sqlService.setSqlRegistry(sqlRegistry());
            return sqlService;
        }
    
        @Bean
        public SqlRegistry sqlRegistry(){
            EmbeddedDbSqlRegistry sqlRegistry = new EmbeddedDbSqlRegistry();
            sqlRegistry.setDataSource(embeddedDatabase());
            return sqlRegistry;
        }
    
        @Bean
        public Unmarshaller unmarshaller(){
            Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
            marshaller.setContextPath("com.ksb.spring.jaxb");
            return marshaller;
        }
    
        @Bean
        public DataSource embeddedDatabase(){
            return new EmbeddedDatabaseBuilder()
                    .setName("embeddedDatabase")
                    .setType(HSQL)
                    .addScript("schema.sql")
                    .build();
        }
    
    }
    ```