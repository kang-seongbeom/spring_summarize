# 7.2 인터페이스의 분리와 자기참조 빈

7.2.1 JAXB(Java Architecture for XML Binding)

- XML에 담긴 정보를 파일에 읽어오는 방법 중 하나
- JAXB는 DOM과 과 같은 전통적인 XML API와 비교했을 때, XML 문서정보를 거의 동일한 구조의 오브젝트로 직접 매칭해줌
- DOM은 XML 정보를 마치 자바의 리플렉션 API를 사용해 조작 하는것 처럼 **간접적**으로 접근해야 함
- JAXB는 XML의 정보르 그대로 담고 있는오브젝트 트리를 만들어주기 때문에, XML 정보를 오브젝트 처럼 **직접적**으로 다룰 수 있어 편리함
- JAXB는 XML 문서의 구조를 정의한 스키마를 이용해서 매핑할 오브젝트의 클래스를 자동으로 만들어주는 **컴파일러**도 제공함
- **스키마 컴파일러**를 통해 자동생성 된 오브젝트에는 매핑정보가 **애노테이션**으로 담겨 있음
- JAXB API는 애노테이션에 담긴 정보를 이용해 XML과 매핑괸 오브젝트 트리 사이의 자동변환 작업을 수행함

![https://dhsim86.github.io/static/assets/img/blog/web/2017-10-10-toby_spring_07_core_apply/00.png](https://dhsim86.github.io/static/assets/img/blog/web/2017-10-10-toby_spring_07_core_apply/00.png)

7.2.2 SQL 맵을 위한 스키마 작성과 컴파일

- <sqlmap>, <sql> 구조를 정의하는 스키마 생성
- 스키마 이름은 sqlmap.xsd

```groovy
// https://mvnrepository.com/artifact/javax.xml.bind/jaxb-api
implementation group: 'javax.xml.bind', name: 'jaxb-api', version: '2.3.1'
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<schema xmlns="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.epril.com/sqlmap"
        xmlns:tns="http://www.epril.com/sqlmap" elementFormDefault="qualified">

    <element name="sqlmap">
        <complexType>
            <sequence>
                <!--unbounded : 필요한 개수만큼 <sql>을 포함할 수 있게 함-->
                <element name="sql" maxOccurs="unbounded" type="tns:sqlType"/>
            </sequence>
        </complexType>
    </element>
    
    <!--<sql>에 대한 정의 시작-->
    <complexType name="sqlType">
        <simpleContent>
            <!--SQL 문장을 넣을 스트링 타입 지정-->
            <extension base="string">
                <!--검색을 위한 키 값은 <sql>의 key 애트리뷰트에 넣음. 필수값임-->
                <attribute name="key" use="required" type="string"/>
            </extension>
        </simpleContent>
    </complexType>
    
</schema>
```

- **셸** 또는 **도스** 창에서 프로젝트 루트 폴더로 이동한 뒤 다음 명령어 사용해 컴파일

```bash
xjc -p {패키지이름} {변환할 스키마 파일} -d {생성된 파일이 저장될 위치}

xjc -p com.ksb.spring.jaxb sqlmap.xsd -d src
```

<aside>
💡 현재 명령어 실행 불가!!

</aside>

7.2.3 책 내용의 문제점 및 대안방법

- 토비의 스프링 책이 발간된지 오래됐음 때문에 레거시 문제가 있음
- 또한, 과거에는 지원 했으나 현재는 지원하지 않는 기능들이 존재함
- JAXB가 대표적인 예시임
- 기존 JDK에 존재하는 JABX 스키마 컴파일러가 JDK 11부터 사라졌음
- 때문에, 책에서 나온 명령어를 통한 [JABX 컴파일러 실행](https://han-jinkyu.tistory.com/14)은 따로 JAXB 스키마 컴파일러를 받아 실행시키지 않는 이상 불가능함
    
    <aside>
    💡 별도로 JAXB 스키마 컴파일러를 받아서 시도 해 봤는데 실패했음
    
    </aside>
    
- [대안방법](https://www.jetbrains.com/help/idea/generating-java-code-from-xml-schema.html)은 존재함(IntellJ Ultimate 사용자만 가능!)
    1. 변환하고자 하는 xsd 파일로 이동
    2. IntelliJ에서 Ctrl+ALT+A 를 동시에 누르기
    3. JAXB 검색
    4. Generate Java Code From XML Schema Using XMLBeans 선택
    5. 원하는 항목 채워넣고 엔터 누르면 파일이 생김
- sqlmap.xsd에서 실행시 Sqlmap, SqlType 클래스 생성

```java
//변환 작업에서 참고할 정보를 애노테이션으로 갖고있음
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "sql"
})
@XmlRootElement(name = "sqlmap", namespace = "http://www.epril.com/sqlmap")
public class Sqlmap {
    @XmlElement(namespace = "http://www.epril.com/sqlmap", required = true)
    protected List<SqlType> sql
    public List<SqlType> getSql() {
        if (sql == null) {
            sql = new ArrayList<SqlType>();
        }
        return this.sql;
    }

}

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "sqlType", namespace = "http://www.epril.com/sqlmap", propOrder = {
    "value"
})
public class SqlType { // <sql> 태그 한 개당 SqlType 오브젝트 하나 씩 생성
    @XmlValue
    protected String value; //SQL 값을 저장할 스트링 타입 필드
    @XmlAttribute(name = "key", required = true)
    protected String key; //검색용 키 값
    public String getValue() {
        return value;
    }
    public void setValue(String value) {
        this.value = value;
    }
    public String getKey() {
        return key;
    }
    public void setKey(String value) {
        this.key = value;
    }
}
```

7.2.4 언마샬링 및 학습 테스트

- XML 문서를 읽어서 자바의 오브젝트로 변환하는 작업을 JAXB에서는 **언마샬링(Unmarshalling)**이라 함
- 이와 대조적으로, 바인딩 오브젝트를 XML 문서로 변환하는 것을 **마샬링(Marshalling)**이라 함
- JABX API를 이용해 언마샬링이 되는지 테스트 할 것임
- 테스트용 SQL 맵 XML 문서 이름 sqlmap.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<sqlmap xmlns="http://www.epril.com/sqlmap"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.epril.com/sqlmap  ./sqlmap.xsd">
    <sql key="add">insert</sql>
    <sql key="get">select</sql>
    <sql key="delete">delete</sql>
</sqlmap>
```

```java
import com.ksb.spring.jaxb.SqlType;
import com.ksb.spring.jaxb.Sqlmap;
...

public class JaxbTest {
    @Test
    public void readSqlmap() throws JAXBException, IOException {
        //바인딩용 클래스들 위치를 가지고 JAXB 컨텍스트를 만듦
        String contextPath = Sqlmap.class.getPackage().getName();
        JAXBContext context = JAXBContext.newInstance(contextPath);
        
        //언마샬러 생성. xml -> 자바 오브젝트
        Unmarshaller unmarshaller = context.createUnmarshaller();

        //언마샬을 하면 매핑된 오브젝트 트리의 루트인 Sqlmap을 반환
        Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(
                getClass().getResourceAsStream("sqlmap.xml")
        );

        //List에 담겨 있는 Sql 오브젝트를 가져와 XML 문서와 같은 정보를 갖는지 확인
        List<SqlType> sqlList = sqlmap.getSql();

        assertThat(sqlList.size() ,is(3));
        assertThat(sqlList.get(0).getKey(), is("add"));
        assertThat(sqlList.get(0).getValue(), is("insert"));
        assertThat(sqlList.get(1).getKey(), is("get"));
        assertThat(sqlList.get(1).getValue(), is("select"));
        assertThat(sqlList.get(2).getKey(), is("delete"));
        assertThat(sqlList.get(2).getValue(), is("delete"));
    }
}
```

7.2.5 SQL 맵 XML 파일

- UserDaoJdbc에 사용할 SQL이 담긴 XML 문서 생성 할 것임
- 스프링 설정의 <map>, <entry>에 담아뒀을 때 보다 의미가 명확함
- SQL은 DAO의 로직 일부이기 때문에 같은 패키지에 두는것이 좋음
- 위에서 만든 sqlmap.xml을 수정

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<sqlmap xmlns="http://www.epril.com/sqlmap"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.epril.com/sqlmap  ./sqlmap.xsd">
    <sql key="userAdd">insert into users(id, name, password, level, login, recommend) value (?,?,?,?,?,?)</sql>
    <sql key="userGet">select * from users where id = ?</sql>
    <sql key="userGetAll">select * from users order by id</sql>
    <sql key="userDeleteAll">delete from users</sql>
    <sql key="userGetCount">select count(*) from users</sql>
    <sql key="userUpdate">update users set name=?, password=?, level=?, login=?, recommend=? where id=?</sql>
</sqlmap>
```

7.2.6 XML SQL 서비스

- sqlmap.xml에 있는 SQL을 가져와 DAO에 제공하는 SqlService 인터페이스의 구현 클래스를 만들 것임
- 언제 JAXB를 이용해 XML 문서를 가져올지 생각해봐야 함
- DAO가 SQL 요청 할 때마다 매번 XML 파일을 읽는 것은 비효율적임
- 특별한 이유가 없는 한, XML 파일은 한 번만 읽도록 해야 함
- XML 파일로 부터 읽은 내용은 어딘가에 저장해두고 DAO에 요청이 올 때 사용되야 함
- 처음 SQL을읽는 건 어디서 해야 하는지에 대해서도 고민해야 함
- SqlService를 구현한 클래스는 빈에 등록이 될 것이고, 언제 어떻게 빈 오브젝트를 생성할 지 알 수 없으니 일단 생성자에서 SQL을 일거와 내부에 저장하는 초기 작업을 할 것임
- 이후에 리팩토링 하면서 코드를 개선할 것음
- JAXB로 XML 문서를 언마샬링하면 SQL 문장 하나는 Sql 클래스 오브젝트에 하나씩 담길 것임
- Map 타입 오브젝트에 저장 하는것이 좋음
- UserDaoTest를 통해 테스트 성공

```java
public class XmlSqlService implements SqlService{
    private Map<String, String> sqlMap = new HashMap<>();

    public XmlSqlService(){
        String contextPath = Sqlmap.class.getPackage().getName();

        try{
            //JAXB API를 이용해 XML 문서를 오브젝트 트리로 읽어옴
            JAXBContext context = JAXBContext.newInstance(contextPath);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            //UserDao와 같은 클래스 패스의 sqlmap.xml 파일 변환
            InputStream is = UserDao.class.getResourceAsStream("sqlmap.xml");
            Sqlmap sqlmap = (Sqlmap) unmarshaller.unmarshal(is);

            //읽어온 SQL을 맵으로 저장
            for(SqlType sql : sqlmap.getSql())
                sqlMap.put(sql.getKey(), sql.getValue());

        } catch (JAXBException e){
            throw new RuntimeException(e);
        }
    }

    @Override
    public String getSql(String key) throws SqlRetrievalFailException {
        String sql = sqlMap.get(key);
        if(sql == null)
            throw new SqlRetrievalFailException(key+"에 대한 SQL을 찾을 수 없습니다.");
        else
            return sql;
    }
}
```

```java
<beans
		...
>
		<bean id="sqlService" class="com.ksb.spring.XmlSqlService">
    </bean>
</beans>
```