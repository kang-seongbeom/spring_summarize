# 7.5 DIë¥¼ ì´ìš©í•´ ë‹¤ì–‘í•œ êµ¬í˜„ ë°©ë²• ì ìš©í•˜ê¸°

7.5.1 ConcurrentHashMapì„ ì´ìš©í•œ ìˆ˜ì • ê°€ëŠ¥ SQL ë ˆì§€ìŠ¤íŠ¸ë¦¬

- ë™ì‹œ ì ‘ì†ìê°€ ë§ì€ ëŒ€í˜• ì‹œìŠ¤í…œì˜ DAOë¼ë©´ ìˆ˜ì‹œë¡œ ì ‘ê·¼í•˜ëŠ” SQL ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì •ë³´ë¥¼ ì˜ëª» ì ‘ê·¼í•˜ë©´ ê¹¨ì§„ SQLì´ ë‚˜íƒ€ë‚  ìˆ˜ ìˆìŒ
- ì§€ê¸ˆê¹Œì§€ ë””í´íŠ¸ë¡œ ì¨ ì™”ë˜ HashMapRegistryëŠ” JDKì˜ HashMapì„ ì‚¬ìš©í•¨
- HashMapì€ ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì˜ **ë™ì‹œì„±**ì— ë¬¸ì œê°€ ìˆìŒ
- ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ HashMapì˜ ë™ì‹œì„±ì„ ìœ„í•´ Collections.synchronizedMap() ë“±ì„ ì´ìš©í•´ ë™ê¸°í™”ë¥¼ í•˜ë©´ ê³ ì„±ëŠ¥ ì„œë¹„ìŠ¤ ì„±ëŠ¥ì— ë§ì€ ë¬¸ì œê°€ ë°œìƒí•¨
- ë•Œë¬¸ì—, ë™ê¸°í™”ëœ í•´ì‹œ ë°ì´í„° ì¡°ì‘ì— ìµœì í™”ëœ ConcurrentHashMapì„ ì‚¬ìš©í•˜ë„ë¡ ê¶Œì¥ë¨

7.5.2 ìˆ˜ì • ê°€ëŠ¥ SQL ë ˆì§€ìŠ¤íŠ¸ë¦¬

- ConcurrentHashMapì„ ì´ìš©í•´ UpdatableSqlRegistryë¥¼ êµ¬í˜„í•  ê²ƒì„
- SQLì„ ë³€ê²½í•˜ëŠ” ê¸°ëŠ¥ì„ ê²€ì¦í•˜ëŠ” ê²ƒì€ ì§€ì¡´ì˜ UserDaoTestë¡œëŠ” ë¶ˆê°€ëŠ¥í•¨
- ë³„ë„ì˜ SQL ì¡°íšŒ ë° ìˆ˜ì • ê¸°ëŠ¥ì„ ê²€ì¦í•˜ëŠ” ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´í•´ì„œ í•´ì•¼í•¨

```java
//ConcurrentHashMapSqlRegistryTest.class
public class ConcurrentHashMapSqlRegistryTest {
    UpdatableSqlRegistry sqlRegistry;

    @Before
    public void setUp(){
        sqlRegistry = new ConcurrentHashMapSqlRegistry();
        //ì‚¬ìš©í•  ì •ë³´ ë¯¸ë¦¬ ë“±ë¡
        sqlRegistry.registrySql("KEY1", "SQL1");
        sqlRegistry.registrySql("KEY2", "SQL2");
        sqlRegistry.registrySql("KEY3", "SQL3");
    }

    @Test
    public void find(){
        checkFindResult("SQL1", "SQL2", "SQL3");
    }

    private void checkFindResult(String expected1, String expected2, String expected3) {
        assertThat(sqlRegistry.findSql("KEY1"), is(expected1));
        assertThat(sqlRegistry.findSql("KEY2"), is(expected2));
        assertThat(sqlRegistry.findSql("KEY3"), is(expected3));
    }

    @Test(expected = SqlNotFoundException.class)
    public void unknownKey(){
        sqlRegistry.findSql("SQLERROR");
    }

    @Test
    public void updateSingle(){
        sqlRegistry.updateSql("KEY2", "modify2");
        checkFindResult("SQL1", "modify2", "SQL3");
    }

    @Test
    public void updateMulti(){
        Map<String, String> sqlmap = new HashMap<>();
        sqlmap.put("KEY1", "modify1");
        sqlmap.put("KEY3", "modify3");

        sqlRegistry.updateSql(sqlmap);
        checkFindResult("modify1", "SQL2", "modify3");
    }

    @Test(expected = SqlUpdateFailureException.class)
    public void updateWithNotExistingKey(){
        sqlRegistry.updateSql("SQLERROR", "modify2");
    }
}

//ConcurrentHashMapSqlRegistry.class
public class ConcurrentHashMapSqlRegistry implements UpdatableSqlRegistry {
    private Map<String, String> sqlMap = new ConcurrentHashMap<>();

    @Override
    public void registrySql(String key, String sql) {
        sqlMap.put(key, sql);
    }

    @Override
    public String findSql(String key) throws SqlRetrievalFailException {
        String sql = sqlMap.get(key);
        if (sql == null)
            throw new SqlNotFoundException(key +
                    "ì— ëŒ€í•œ SQLì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        else
            return sql;
    }

    @Override
    public void updateSql(String key, String sql) throws SqlUpdateFailureException{
            if(sqlMap.get(key) == null){
                throw new SqlUpdateFailureException(key +
                        "ì— ëŒ€í•œ SQLì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            }
        sqlMap.put(key, sql);
    }

    @Override
    public void updateSql(Map<String, String> sqlmap)
            throws SqlUpdateFailureException{
        for(Map.Entry<String, String> entry : sqlmap.entrySet()){
            updateSql(entry.getKey(), entry.getValue());
        }
    }
}
```

```xml
<beans>
		<bean id="sqlService" class="com.ksb.spring.OxmSqlService">
        <property name="unmarshaller" ref="unmarshaller"/>
        <property name="sqlmap" value="classpath:/sqlmap.xml"/>
        <!--ë””í´íŠ¸ì¸ HashMapSqlRegistry ëŒ€ì‹  ì‚¬ìš© í•  ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë“±ë¡-->
        <property name="sqlRegistry" ref="sqlRegistry"/>
    </bean>

    <bean id="sqlRegistry" class="com.ksb.spring.ConcurrentHashMapSqlRegistry">
    </bean>
</beans>
```

7.5.3 ë‚´ì¥í˜• ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì´ìš©í•œ SQL ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë§Œë“¤ê¸°

- ConcurrentHashMap ëŒ€ì‹  **ë‚´ì¥í˜• DB(Embedded DB)**ë¥¼ ì´ìš©í•  ê²ƒì„
- ConcurrentHashMapëŠ” ë°ì´í„°ê°€ ë§ì•„ì§€ê³ , ì¡°íšŒ ë° ìˆ˜ì •ì´ ë¹ˆë²ˆíˆ ë°œìƒí•˜ë©´ ì„±ëŠ¥ì˜ í•œê³„ê°€ ìˆìŒ
- SQL ë•Œë¬¸ì— ìƒˆë¡œìš´ ì™¸ë¶€ DBì— ì‚¬ìš©í•˜ê¸°ì—ëŠ” ë§ì€ ë¶€ë‹´ì´ ìˆê¸° ë•Œë¬¸ì— ë‚´ì¥í˜• DBë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŒ
- ë‚´ì¥í˜• DBëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ê³¼ í•¨ê»˜ ì‹œì‘ë˜ê³  ì¢…ë£Œë˜ëŠ” DBì´ê¸° ë•Œë¬¸ì—, ë°ì´í„°ëŠ” **ë©”ëª¨ë¦¬**ì— ì €ì¥ë¨
- ë‚´ì¥í˜• DBëŠ” ì»¬ë ‰ì…˜ì— ë¹„í•´ ë™ì‹œì„± ë° ì•ˆì •ì ì¸ CRUDë¥¼ í•  ìˆ˜ ìˆìŒ
- ìµœì í™”ëœ ë½í‚¹, ê²©ë¦¬ìˆ˜ì¤€, íŠ¸ëœì­ì…˜ì„ ì ìš©í•  ìˆ˜ë„ ìˆìŒ
- ìë°”ì—ì„œ ì‚¬ìš©ë˜ëŠ” ëŒ€í‘œì  ë°ì´í„°ë² ì´ìŠ¤ëŠ” ì„¸ ê°€ì§€ê°€ ìˆìŒ
    1. Derby
    2. HSQL
    3. H2
- ì„¸ ê°€ì§€ ë°ì´í„°ë² ì´ìŠ¤ëŠ” JDBC ë“œë¼ì´ë²„ë¥¼ ì œê³µí•˜ê³ , í‘œì¤€ DBì™€ í˜¸í™˜ë˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•˜ê¸° ë•Œë¬¸ì— JDBC í”„ë¡œê·¸ë˜ë° ëª¨ë¸ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
- í•˜ì§€ë§Œ, ë‚´ì¥í˜• DBëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ **ìƒëª…ì£¼ê¸°**ì™€ ê°™ì´í•˜ê¸° ë•Œë¬¸ì—, ì• í”Œë¦¬ì¼€ì´ì…˜ ë‚´ì—ì„œ DBë¥¼ ê°€ë™ì‹œí‚¤ê³  ì´ˆê¸°í™”í•˜ëŠ” SQL ìŠ¤í¬ë¦½íŠ¸ ë“±ì˜ ì´ˆê¸°í™” ì‘ì—…ì´ í•„ìš”í•¨
- ì´ëŸ¬í•œ ì´ìœ  ë•Œë¬¸ì— JDBC í”„ë¡œê·¸ë˜ë° ëª¨ë¸ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì ì ˆí•˜ì§€ ì•ŠìŒ
- ìŠ¤í”„ë§ì€ ë‚´ì¥í˜• DBë¥¼ ì†ì‰½ê²Œ ì‚¬ìš©í•˜ë„ë¡ ë‚´ì¥í˜• DB ì§€ì› ê¸°ëŠ¥ì„ ì œê³µí•˜ê³  ìˆìŒ
- ìŠ¤í”„ë§ì€ ë‚´ì¥í˜• DBë¥¼ **ì´ˆê¸°í™”**í•˜ëŠ” ì‘ì—…ì„ ì§€ì›í•˜ëŠ” **ë‚´ì¥í˜• DB ë¹Œë”**ë¥¼ ì œê³µí•¨
- ë‚´ì¥í˜• DB ë¹Œë”ëŠ” **ë“œë¼ì´ë²„ ì´ˆê¸°í™”** ë° í…Œì´ë¸” ìƒì„±ê³¼ ë°ì´í„°ë¥¼ ì‚½ì…í•˜ëŠ” **SQL ì‹¤í–‰**ì„í•¨
- ë‚´ì¥í˜• DB ë¹Œë”ê°€ ì‘ì—…ì„ ë§ˆì¹˜ë©´ `DataSource` ì˜¤ë¸Œì íŠ¸ë¥¼ ë°˜í™˜í•¨
- ì •í™•íˆëŠ”, ìŠ¤í”„ë§ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ ë‚´ë¶€ì—ì„œ DB **ì¢…ë£Œ ìš”ì²­**ì„ í•  ìˆ˜ ìˆëŠ” `DataSource`ë¥¼ ìƒì†í•œ `EmbeddedDatabase` ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•¨
- ì¢…ë£Œ ìš”ì²­ì€ shutdown() ë©”ì†Œë“œë¥¼ í†µí•´ í•  ìˆ˜ ìˆìŒ

7.5.4 ë‚´ì¥í˜• DB ë¹Œë” í•™ìŠµ í…ŒìŠ¤íŠ¸

- ë‚´ì¥í˜• DB ì§€ì› ê¸°ëŠ¥ì— ëŒ€í•œ í•™ìŠµ í…ŒìŠ¤íŠ¸ì„
- ë‚´ì¥í˜• DBëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì„ í†µí•´ í…Œì´ë¸”ì„ ë§¤ë²ˆ ìƒì„±í•˜ê¸° ë•Œë¬¸ì— ìƒì„± SQL ìŠ¤í¬ë¦½íŠ¸ê°€ í•„ìš”í•¨
- í•´ë‹¹ ìƒì„± SQL ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼ ì´ë¦„ì„ schema.sqlì´ë¼ ì§€ì •í•¨
- ë˜í•œ, ì´ˆê¸° ë°ì´í„° ë“±ë¡ì„ ìœ„í•œ SQL ë¬¸ë„ ì¶”ê°€

```groovy
testImplementation group: 'hsqldb', name: 'hsqldb', version: '1.8.0.7'
```

```sql
-- schema.sql
CREATE TABLE SQLMAP(
    KEY_ VARCHAR(100) PRIMARY KEY,
    SQL_ VARCHAR(100) NOT NULL
);

--data.sql
INSERT INTO SQLMAP(KEY_, SQL_) VALUE('KEY1', 'SQL1');
INSERT INTO SQLMAP(KEY_, SQL_) VALUE('KEY2', 'SQL2');
```

```java
import static org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType.HSQL;
...

public class EmbeddedDbTest {
    EmbeddedDatabase db;
    NamedParameterJdbcTemplate template;

    @Before
    public void setUp(){
        db= new EmbeddedDatabaseBuilder()
                .setType(HSQL)
                .addScript("/schema.sql")
                .addScript("/data.sql")
                .build();

        template = new NamedParameterJdbcTemplate(db);
    }

    @After
    public void tearDown(){
        db.shutdown();
    }

    @Test
    public void initData(){
        String sql = "select count(*) from sqlmap";
        Map<String, String> params = Collections.singletonMap(":null", "null");
        // ë‘ ë²ˆì§¸ ê°’ì€ ì“°ë ˆê¸° ê°’ì„
        assertThat(template.queryForObject(sql, params,Integer.class), is(2));

        sql = "select * from sqlmap order by key_";
        params = Collections.singletonMap(":key_", "key_");
        List<Map<String, Object>> list = template.queryForList(sql, params);
        assertThat((String)list.get(0).get("key_"), is("KEY1"));
        assertThat((String)list.get(0).get("sql_"), is("SQL1"));
        assertThat((String)list.get(1).get("key_"), is("KEY2"));
        assertThat((String)list.get(1).get("sql_"), is("SQL2"));
    }

    @Test
    public void insert(){
        String sql = "insert into sqlmap(key_, sql_) values(:key_, :sql_)";
        Map<String,String> params = new HashMap<>();
        params.put("key_", "KEY3");
        params.put("sql_", "SQL3");
        template.update(sql, params);

        sql = "select count(*) from sqlmap";
        params = Collections.singletonMap(":null", "null");
        assertThat(template.queryForObject(sql, params,Integer.class), is(3));
    }
}
```

<aside>
ğŸ’¡ ì±…ì— ë‚˜ì˜¨ SimpleJdbcTemplateëŠ” Deprecated ë˜ì—ˆê¸° ë•Œë¬¸ì—, NamedParameterJdbcTemplateë¥¼ ì‚¬ìš©í–ˆìŒ

</aside>

7.5.5 ë‚´ì¥í˜• DBë¥¼ ì´ìš©í•œ SqlRegistry ë§Œë“¤ê¸°

- ìŠ¤í”„ë§ì—ì„œ ê°„ë‹¨íˆ ë‚´ì¥í˜• DBë¥¼ ì´ìš©í•˜ë ¤ë©´ `EmbeddedDatabaseBuilder`ë¥¼ ì‚¬ìš©í•˜ë©´ ë¨
- `EmbeddedDatabaseBuilder`ëŠ” ì´ˆê¸°í™” ì‘ì—…ì´ ë™ë°˜ë˜ì•¼ í•˜ê¸° ë•Œë¬¸ì—, ë¹ˆìœ¼ë¡œ ë“±ë¡í•œë‹¤ê³  ë°”ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê²ƒì´ ì•„ë‹˜
- ì´ˆê¸°í™” ì½”ë“œê°€ í•„ìš”í•˜ë©´ íŒ©í† ë¦¬ ë¹ˆìœ¼ë¡œ ë§Œë“œëŠ” ê²ƒì´ ì¢‹ìŒ
    
    <aside>
    ğŸ’¡ íŒ©í† ë¦¬ ë¹ˆì€ XMLì„ í†µí•œ ë¹ˆìœ¼ë¡œ ë“±ë¡í•˜ì§€ ëª»í•˜ê³ , newInstance()ì²˜ëŸ¼ ìŠ¤íƒœí‹± ë©”ì†Œë“œë¡œ ì˜¤ë¸Œì íŠ¸ë¥¼ ë§Œë“¤ì–´ì•¼ í•˜ëŠ” ê²ƒì„ ìŠ¤í”„ë§ ë¹ˆìœ¼ë¡œ ë“±ë¡í•˜ê²Œ í•´ ì£¼ëŠ” ê²ƒì„. [6.3 ë‹¤ì´ë‚´ë¯¹ í”„ë¡ì‹œì™€ íŒ©í† ë¦¬ë¹ˆ ì°¸ê³ ]
    
    </aside>
    
- ìŠ¤í”„ë§ì—ì„œ íŒ©í† ë¦¬ ë¹ˆì„ ë§Œë“œëŠ” ë²ˆê±°ë¡œìš´ ì‘ì—…ì„ ëŒ€ì‹ í•´ì£¼ëŠ” **ì „ìš© íƒœê·¸**ê°€ ìˆìŒ
- ì „ìš© íƒœê·¸ëŠ” jdbc ìŠ¤í¬ë§ˆì— ì •ì˜ë˜ì–´ ìˆìŒ
    
    <aside>
    ğŸ’¡ ì „ìš© íƒœê·¸ëŠ” 7.5.8ì—ì„œ í™•ì¸
    
    </aside>
    

```java
public class EmbeddedDbSqlRegistry implements UpdatableSqlRegistry{
    NamedParameterJdbcTemplate jdbc;

    /*
        ë‚´ì¥ DB ë¹Œë”ê°€ Datasourceì˜ ì„œë¸Œ ì¸ìŠ¤í„´ìŠ¤ì¸ EmbeddedDatebaseë¥¼ ë°˜í™˜ í•´ë„
        Datasourceë¡œ ì¸ìë¥¼ ë°›ëŠ” ì´ìœ ëŠ”, ì¸í„°í˜ì´ìŠ¤ ë¶„ë¦¬ ì›ì¹™ì„ ì§€í‚¤ê¸° ìœ„í•¨ì„.
        í´ë¼ì´ì–¸íŠ¸ëŠ” ìì‹ ì´ í•„ìš”í•œ ê¸°ëŠ¥ì„ ê°€ì§„ ì¸í„°í˜ì´ìŠ¤ë¥¼ DI ë°›ì•„ì•¼í•¨.
        SQL ë ˆì§€ìŠ¤íŠ¸ë¦¬ëŠ” JDBCë¥¼ ì´ìš©í•´ DBì— ì ‘ê·¼ë§Œ í•˜ë©´ ë˜ë¯€ë¡œ Datasourceê°€ ê°€ì¥ ì í•©í•¨
     */
    public void setDataSource(DataSource dataSource){
        jdbc = new NamedParameterJdbcTemplate(dataSource);
    }

    @Override
    public void registrySql(String key, String sql){
        Map<String,String> params = new HashMap<>();
        params.put("key_", key);
        params.put("sql_", sql);

        jdbc.update("insert into sqlmap(key_, sql_) values(:key_, :sql_)", params);
    }

    @Override
    public String findSql(String key) throws SqlRetrievalFailException {
        try{
            Map<String, String> params = Collections.singletonMap("key_", key);
            return jdbc.queryForObject("select sql_ from sqlmap where key_ = :key_",
                    params, String.class);
        }catch (EmptyResultDataAccessException e){
            throw new SqlNotFoundException(key + "ì— í•´ë‹¹í•˜ëŠ” SQLì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        }
    }

    @Override
    public void updateSql(String key, String sql) {
        Map<String,String> params = new HashMap<>();
        params.put("sql_", sql);
        params.put("key_", key);
        int affected = jdbc.update("update sqlmap set sql_ = :sql_ where key_ = :key_",
                params);
        if(affected == 0){
            throw new SqlUpdateFailureException(key+"ì— í•´ë‹¹í•˜ëŠ” SQLì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        }
    }

    @Override
    public void updateSql(Map<String, String> sqlmap) {
        for(Map.Entry<String, String> entry : sqlmap.entrySet()){
            updateSql(entry.getKey(), entry.getValue());
        }
    }
}
```

7.5.6 UpdatableSqlRegistry í…ŒìŠ¤íŠ¸ ì½”ë“œì˜ ì¬ì‚¬ìš©

- `EmbeddedDbSqlRegistry`ë„ ê²€ì¦ì„ í•´ì•¼ í•¨
- ê·¼ë°, ì´ì „ì— ë§Œë“  `ConcurrentHashMapSqlRegistry`ì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œì™€ ëŒ€ë¶€ë¶„ ì¤‘ë³µë¨
- ë”°ë¼ì„œ, í…ŒìŠ¤íŠ¸ ì½”ë“œ **ìƒì†**ì„ í†µí•´ ê³µìœ í•  ìˆ˜ ìˆê²Œ í•¨
- `ConcurrentHashMapSqlRegistryTest`ì˜ ì½”ë“œ ì¤‘ì—ì„œ `ConcurrentHashMapSqlRegistry`ì— ì˜ì¡´í•˜ëŠ” ë¶€ë¶„ì€ **í•œ ì¤„**ì„
    
    ```java
    public class ConcurrentHashMapSqlRegistryTest {
    		//
        UpdatableSqlRegistry sqlRegistry;
    
        @Before
        public void setUp(){
            sqlRegistry = new ConcurrentHashMapSqlRegistry(); //ì˜ì¡´
            ...
        }
    }
    ```
    
- ë‚˜ë¨¸ì§€ ì½”ë“œëŠ” `UpdatableSqlRegistry` ì¸í„°í˜ì´ìŠ¤ì—ë§Œ ì˜ì¡´í•˜ê³  ìˆìŒ
- ë”°ë¼ì„œ ì˜¤ë¸Œì íŠ¸ ìƒì„± ë¶€ë¶„ë§Œ ë¶„ë¦¬ë¥¼ í•˜ë©´ ë¨
- ë˜í•œ, ì˜¤ë¸Œì íŠ¸ ìƒì„± ë¶€ë¶„ì„ ë¶„ë¦¬í•˜ë©´ `UpdatableSqlRegistry` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ ëª¨ë“  í´ë˜ìŠ¤ì˜ í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆëŠ” ì¶”ìƒ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ë¡œ ë³€ê²½ë¨
- ë•Œë¬¸ì—, `ConcurrentHashMapSqlRegistryTest`ë¥¼ `AbstractUpdateSqlRegistryTest`ë¡œ ë³€ê²½
    
    ```java
    //AbstractUpdateSqlRegistryTest.class
    public abstract class AbstractUpdateSqlRegistryTest {
        UpdatableSqlRegistry sqlRegistry;
    
        @Before
        public void setUp(){
            sqlRegistry = createUpdatableSqlRegistry();
            ...
        }
        
        abstract protected UpdatableSqlRegistry createUpdatableSqlRegistry();
    
    		//ìƒì† ê°€ëŠ¥í•˜ê²Œ ì ‘ê·¼ ì§€ì‹œì ë³€ê²½
        protected void checkFindResult(String expected1, String expected2, String expected3) {
            ...
        }
    		...
    }
    
    //ConcurrentHashMapSqlRegistryTest.class
    public class ConcurrentHashMapSqlRegistryTest extends  AbstractUpdateSqlRegistryTest{
        @Override
        protected UpdatableSqlRegistry createUpdatableSqlRegistry() {
            return new ConcurrentHashMapSqlRegistry();
        }
    }
    ```
    

7.5.7 EmbeddedDbSqlRegistryTest

- `EmbeddedDbSqlRegistry`ì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤

```java
public class EmbeddedDbSqlRegistryTest extends AbstractUpdateSqlRegistryTest{
    EmbeddedDatabase db;

    @Override
    protected UpdatableSqlRegistry createUpdatableSqlRegistry() {
        db = new EmbeddedDatabaseBuilder()
                .setType(HSQL)
                .addScript("/schema.sql")
                .build();

        EmbeddedDbSqlRegistry embeddedDbSqlRegistry = new EmbeddedDbSqlRegistry();
        embeddedDbSqlRegistry.setDataSource(db);

        return embeddedDbSqlRegistry;
    }

    @After
    public void tearDown(){
        db.shutdown();
    }
}
```

7.5.8 XML ì„¤ì •ì„ í†µí•œ ë‚´ì¥í˜• DB ìƒì„±ê³¼ ì ìš©

- jdbc ìŠ¤í‚¤ë§ˆ **ì „ìš© íƒœê·¸**ë¥¼ ì‚¬ìš©í•œ EmbeddedDbSqlRegistry ì ìš©
- jdbc ì „ìš© íƒœê·¸ì— ì˜í•´ ë§Œë“¤ì–´ì§€ëŠ” `EmbeddedDatabase` íƒ€ì… ë¹ˆì€ ì»¨í…Œì´ë„ˆê°€ ì¢…ë£Œë  ë•Œ, ìë™ìœ¼ë¡œ shutdown() ë©”ì†Œë“œê°€ í˜¸ì¶œë¨
- UserDaoTestê°€ ì„±ê³µë˜ì•¼ í•¨

```xml
<beans ...
				xmlns:jdbc="http://www.springframework.org/schema/jdbc"
				xsi:schemaLocation="http://www.springframework.org/schema/jdbc
                    http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd">
		...
		<jdbc:embedded-database id="embeddedDatabase" type="HSQL">
        <jdbc:script location="schema.sql"/>
    </jdbc:embedded-database>

		<bean id="sqlRegistry" class="com.ksb.spring.EmbeddedDbSqlRegistry">
        <property name="dataSource" ref="embeddedDatabase"/>
    </bean>
</beans>

```

7.5.9 íŠ¸ëœì­ì…˜ ì ìš©

- ë‚´ì¥í˜• DBëŠ” ì•ˆì „í•˜ê²Œ SQLì„ ìˆ˜ì •í•˜ë„ë¡ ë³´ì¥í•´ì¤Œ
- í•˜ì§€ë§Œ, íŠ¸ëœì­ì…˜ ì ìš©ì„ í•˜ì§€ ì•Šì•„ SQL ìˆ˜ì • ë„ì¤‘ ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´, ìˆ˜ì • ì„±ê³µí•œ ê²ƒë§Œ ì ìš©ë˜ì–´ í° ë¬¸ì œë¥¼ ë°œìƒí•  ìˆ˜ ìˆìŒ
- ë•Œë¬¸ì— íŠ¸ëœì­ì…˜ì„ ì ìš©í•´ì•¼ í•¨
- ìŠ¤í”„ë§ì—ì„œ íŠ¸ëœì­ì…˜ì„ ì ìš©í•  ë•Œ, íŠ¸ëœì­ì…˜ ê²½ê³„ê°€ DAO ë°–ì— ìˆê³ , ë²”ìœ„ê°€ ë„“ì€ ê²½ìš° AOPë¥¼ ì´ìš©í•˜ëŠ” ê²ƒì´ í¸ë¦¬í•¨
- í•˜ì§€ë§Œ, SQL ë ˆì§€ìŠ¤íŠ¸ë¦¬ë¼ëŠ” ì œí•œëœ ì˜¤ë¸Œì íŠ¸ ë‚´ì—ì„œ íŠ¹í™”ë˜ê³  ê°„ë‹¨í•œ íŠ¸ëœì­ì…˜ì´ í•„ìš”í•œ ê²½ìš° íŠ¸ëœì­ì…˜ APIë¥¼ ì§ì ‘ ì´ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŒ

7.5.10 ë‹¤ì¤‘ SQL ìˆ˜ì •ì— ëŒ€í•œ íŠ¸ëœì­ì…˜ í…ŒìŠ¤íŠ¸

- íŠ¸ëœì­ì…˜ì˜ ì ìš©ì€ ìˆ˜ë™ í…ŒìŠ¤íŠ¸ ë”°ìœ„ë¡œ ê²€ì¦í•˜ê¸° ë§¤ìš° ì–´ë ¤ì›€
- íŠ¸ëœì­ì…˜ ë„ì¤‘ì— ê°•ì œë¡œ ì—ëŸ¬ë¥¼ ë°œìƒí•˜ê¸°ëŠ” ë§¤ìš° ì–´ë µê¸° ë•Œë¬¸ì„
- ê·¸ëŸ¬ë¯€ë¡œ íŠ¸ëœì­ì…˜ ì ìš©ì´ ì„±ê³µí•˜ê³  ì•„ë‹ˆë¼ë©´ ì‹¤íŒ¨í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì½”ë“œë¥¼ ë¨¼ì € ë§Œë“¤ì–´ì•¼ í•¨
- ì´ í…ŒìŠ¤íŠ¸ëŠ” ì‹¤íŒ¨í•˜ë„ë¡ ë§Œë“œëŠ” ê²ƒì´ ëª©ì ì„

```java
public class EmbeddedDbSqlRegistryTest extends AbstractUpdateSqlRegistryTest{
		...
    @Test
    public void transactionalUpdate(){
        checkFindResult("SQL1", "SQL2", "SQL3");

        Map<String,String> sqlmap = new HashMap<>();
        sqlmap.put("KEY1", "modify1");
        sqlmap.put("keyError", "modify2"); //í‚¤ë¥¼ ëª»ì°¾ê¸° ë•Œë¬¸ì— ì‹¤íŒ¨í•  ê²ƒì„

        try{
            sqlRegistry.updateSql(sqlmap);
        }catch (SqlUpdateFailureException e){
        }

        //íŠ¸ëœì­ì…˜ ì ìš© ë˜ë©´ ë¡¤ë°±ë  ê²ƒì´ê¸° ë•Œë¬¸ì— ì›ë˜ ìƒíƒœë¡œ ëŒì•„ì™€ì•¼ í•¨
        //ë§Œì•½ íŠ¸ëœì­ì…˜ ì ìš©ë˜ì§€ ì•Šìœ¼ë©´ ì²« ë²ˆì§¸ê°€ modify1ìœ¼ë¡œ ë  ê²ƒì„
        //ë•Œë¬¸ì— checkFindResult() ì‹¤íŒ¨
        checkFindResult("SQL1", "SQL2", "SQL3");
    }
}
```

7.5.11 ì½”ë“œë¥¼ ì´ìš©í•œ í‹€ëœì­ì…˜ ì ìš©

- `PlatformTransactionManager`ë¥¼ ì§ì ‘ ì‚¬ìš©í•´ì„œ íŠ¸ëœì­ì…˜ ì½”ë“œë¥¼ ë§Œë“œëŠ” ê²ƒ ë³´ë‹¤, í…œí”Œë¦¿/ì½œë°± íŒ¨í„´ì„ ì ìš©í•œ `TransactionTemplate`ë¥¼ ì“°ëŠ”ê²ƒì´ ì¢‹ìŒ
- íŠ¸ëœì­ì…˜ ë§¤ë‹ˆì €ë¥¼ ê³µìœ í•  í•„ìš”ê°€ ì—†ê¸° ë•Œë¬¸ì— ë²ˆê±°ë¡­ê²Œ ë¹ˆìœ¼ë¡œ ë§Œë“œëŠ” ëŒ€ì‹ , ì§ì ‘ ë§Œë“¦

```java
public class EmbeddedDbSqlRegistry implements UpdatableSqlRegistry {
    //ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ê³µìœ  ê°€ëŠ¥
    TransactionTemplate transactionTemplate;
		...

		public void setDataSource(DataSource dataSource) {
        jdbc = new NamedParameterJdbcTemplate(dataSource);
        transactionTemplate = new TransactionTemplate(
                new DataSourceTransactionManager(dataSource)
        );
    }

		//ìµëª… ë‚´ë¶€ í´ë˜ìŠ¤ì—ì„œ ì¸ìë¥¼ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì— finalì„ ë¶™ì—¬ì•¼ í•¨
    @Override
    public void updateSql(final Map<String, String> sqlmap) {
        //íŠ¸ëœì­ì…˜ í…œí”Œë¦¿ì´ ë§Œë“œëŠ” íŠ¸ëœì­ì…˜ ê²½ê³„ ì•ˆì—ì„œ ë™ì‘í•  ì½”ë“œë¥¼ ì½œë°± í˜•íƒœë¡œ ë§Œë“¤ê³ 
        //TransactionTemplateì˜ execute() ë©”ì†Œë“œì— ì „ë‹¬í•´ì•¼ í•¨
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                for (Map.Entry<String, String> entry : sqlmap.entrySet()) {
                    updateSql(entry.getKey(), entry.getValue());
                }
            }
        });
    }
}
```