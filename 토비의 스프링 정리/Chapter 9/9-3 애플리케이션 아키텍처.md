# 9.3 애플리케이션 아키텍처

9.3.1 아키텍처와 SoC

- 지금까지 주로 오브젝트 레벨에서 관심, 성격, 책임의 분리를 진행했음
- 이 원리는 아키텍처 레벨에서도 동일하게 적용할 수 있음아롷개 챡
- 데이터 액세스 로직을 담당하는 DAO들만 하나의 단위로 묶고, 비즈니스 서비스만 하나의 단위로 묶을 수 있음
    
    <aside>
    💡 서비스 오브젝트들은 POJO로 만들어짐. 밑에서 나오지만, 서비스 계층과 기반 서비스 계층은 다름
    
    </aside>
    
- 성격이 다른 것은 아키텍처 레벨에서 분리하면 독자적인 개발 및 테스트가 가능해 개발과 변경이 모두 빨라질 수 있음
- 이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리하는 아키텍처를 **계층형 아키텍처(Layered Architecture)** 또는 **멀티 티어 아키텍처**라고 함
- 보통 웹 기반의 엔터프라이즈 애플리케이션은 세 개의 계층을 갖는다고 해서 **3계층 애플리케이션**이라고도 함

9.3.2 3계층 아키텍처와 수직 계층

- 3계층 아키텍처는 **데이터 액세스**, **서비스**, **프레젠테이션** 계층으로 구분함
    
    [https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FreBmw%2FbtqGmTmJeMM%2FddqFjx0DfEwMvdclBHVsz0%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FreBmw%2FbtqGmTmJeMM%2FddqFjx0DfEwMvdclBHVsz0%2Fimg.png)
    
- 데이터 액세스 계층
    - 데이터 액세스 계층은 DAO 계층이라고도 불림
    - 또한 데이터 액세스 계층은 DB 외에도 ERP, 레거시 시스템, 메인프레임 들에 접근하는 역할을 하기 때문에 EIS(Enterprise Information System) 계층이라고도 함
    - 또, 외부 시스템을 호출해서 서비스를 이용하는 것은 기반(Infrastructure) 계층으로 따로 분류하기도 함
    - 데이터 액세스 계층은 사용 기술에 따라 세분화된 계층으로 구분할 수 있음
        
        [https://camo.githubusercontent.com/ccf4442c673de98036c40b2cf6ee47c75348d355c62001bf8b1c24b78ed878e6/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6464506450472f62747176774d4c386d5a672f4b57324b5a39416c46483555354d636453696a4b576b2f696d672e706e67](https://camo.githubusercontent.com/ccf4442c673de98036c40b2cf6ee47c75348d355c62001bf8b1c24b78ed878e6/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6464506450472f62747176774d4c386d5a672f4b57324b5a39416c46483555354d636453696a4b576b2f696d672e706e67)
        
    - 세분화된 계층은 추상화 수준에 따른 구분이기 때문에 **수직적인 계층**이라고도 함
    - 새로운 추상화된 계층을 추가하면 코드에 지대한 영향을 끼치기 때문에 신중해야 함
- 서비스 계층
    - 서비스 계층은 이상적인 POJO로 작성됨
    - POJO로 만든다면 비즈니스 로직의 핵심을 잘 담아내고, 이를 유연하게 확장할 수 있음
    - 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없음
    - 기술 API를 직접 다루지 않기 때문에 추상화가 필요 없기 때문임
    - 비즈니스 로직을 담은 **서비스 계층**과 엔터프라이즈 서비스를 제공하는 **기반 서비스 계층**을 잘 구분해야 함
        
        [https://camo.githubusercontent.com/084a71b81ca89d91a2c8d92710f464a6ddb8e2da667099626a2b8fab609470d8/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f647a415451432f627471476e4945535062492f4169635571586b6b39646b5959354b424b427a3377312f696d672e706e67](https://camo.githubusercontent.com/084a71b81ca89d91a2c8d92710f464a6ddb8e2da667099626a2b8fab609470d8/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f647a415451432f627471476e4945535062492f4169635571586b6b39646b5959354b424b427a3377312f696d672e706e67)
        
    - 일반적으로 서비스 계층에서 기반 서비스 계층의 API를 호출해 이용함
    - 반대로 서비스 계층의 코드를 기반 서비스 계층에서 사용할 수 도 있음
    - 스케줄링이 대표적인 예시임
    - 정해진 시간에 백그라운드 서비스가 필요할 때 기반 서비스 계층에서 서비스 계층의 오브젝트를 이용하게 할 수 있음
    - 원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되지 않도록 **인터페이스**를 이용해야 함
    - 또는 AOP를 이용해 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 함
    - 이상적인 서비스 계층은 데이터 액세스 및 프레젠테이션 계층이 변경되더라도 그대로 유지할 수 있어야 함
- 프레젠테이션 계층
    - 가장 복잡한 계층임
    - 프레젠테이션 계층은 매우 다양한 기술과 프레임워크의 조합을 가질 수 있음
    - 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 됨
    - 프레젠테이션 계층은 다른 계층과 달리 클라이언트까지 그 범위를 확장시킬 수 있음
    - 프레젠테이션 로직이 클라이언트로 이동된 대표적인 아키텍처가 **RIA(Rich Internet Architecture)**와 **SOFEA(Service Oriented Front End Architecture)**가 있음

9.2.3 계층형 아키텍처 설계의 원칙

- 각 계층은 높은 응집도와 낮은 결합도를 가져야 함
- 즉, 자신의 역할에만 충실하고 관련 기술이 아닌 API는 사용해선 안됨
- 자신의 역할에 충실하면, 필요한 그 밖의 작업은 **인터페이스**를 통해 다른 계층에 요청됨
- 아래 코드는 `ResulteSet`을 반환하기 때문에, JDBC에 의존적임
    
    ```java
    public ResulteSet findUsersByName(String name) throw SQLException;
    ```
    
- 또한, 체크 예외로 인해 서비스 계층에서 `SQLException`을 해석해야 하기 때문에 강한 결합이 발생함
- 아래 코드와 같이 단순한 오브젝트 형태로 전달해야 함
    
    ```java
    public List<User> findUsersByName(String name) throw DataAccessException;
    ```
    
- 또한, 런타임 예외로 던져야 함
- 흔히 저지르는 실수 중 하나는 프레젠테이션 계층의 오브젝트 형태 그대로 서비스 계층에 전달하는 것임
- 서블릿의 `HttpServletRequest`나 `HttpSession` 같은 타입을 파라미터로 사용하면 안됨
- 계층 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해야 함
- 스프링의 DI는 기본적으로 오브젝트 사이의 관계를 다룸
- 따라서 계층 사이의 경계나 그 관계에 직접적인 관여를 하지 않음
- 즉, 계층을 구분하지 않기 때문에 빈 사이의 **의존관계**를 만들 때 주의해야 함
- 한 계층에서만 사용하도록 만든 빈을 다른 계층에서 사용하면 안된다는 뜻임